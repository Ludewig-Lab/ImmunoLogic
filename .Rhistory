cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
cellwidth = 15,
cellheight = 10,
color_palette = NULL,
annotation_colors = NULL,
gaps_row = NULL,
gaps_col = NULL,
n_variable_genes = 20,
...) {
# Handle gene input - can be vector of gene names or data.frame with gene column
# If no genes provided, use top variable features
if (is.null(selGenes)) {
# Get top n highly variable features as default
if ("SCT" %in% names(seurat@assays)) {
# If SCT assay exists, use its variable features
variable_features <- VariableFeatures(seurat, assay = "SCT")
} else {
# Otherwise use RNA assay variable features
variable_features <- VariableFeatures(seurat, assay = "RNA")
}
if (length(variable_features) == 0) {
stop("No variable features found. Please run FindVariableFeatures() first or provide selGenes manually.")
}
gene_list <- head(variable_features, n_variable_genes)
message("No genes provided. Using top ", n_variable_genes, " variable features: ",
paste(head(gene_list, 5), collapse = ", "), "...")
} else if (is.data.frame(selGenes)) {
if ("gene" %in% colnames(selGenes)) {
gene_list <- selGenes$gene
} else if ("geneID" %in% colnames(selGenes)) {
gene_list <- selGenes$geneID
} else {
gene_list <- selGenes[, 1]  # Use first column if no standard column names
}
} else {
gene_list <- selGenes
}
# Set grouping variable - default to active identity
if (is.null(group_by)) {
group_by <- "ident"
clusterAssigned <- data.frame(
ident = Idents(seurat),
cell = names(Idents(seurat))
)
} else {
clusterAssigned <- data.frame(
ident = seurat@meta.data[[group_by]],
cell = rownames(seurat@meta.data)
)
}
# Remove cells with NA identities and warn user
na_cells <- is.na(clusterAssigned$ident)
if (any(na_cells)) {
n_na <- sum(na_cells)
warning("Removed ", n_na, " cells with NA identities (",
round(n_na/nrow(clusterAssigned)*100, 2), "% of cells)")
clusterAssigned <- clusterAssigned[!na_cells, ]
}
# Convert ident to character to avoid factor level issues
clusterAssigned$ident <- as.character(clusterAssigned$ident)
# Get assay data
seuratDat <- GetAssayData(seurat, assay = "RNA", slot = "data")
# Find genes in the Seurat object
# Handle ENSEMBL IDs if present (assumes format: ENSEMBL.SYMBOL)
genes <- data.frame(gene = rownames(seurat)) %>%
mutate(geneID = gsub("^.*\\.", "", gene))
# Match genes more flexibly
if (all(grepl("^ENSG", gene_list))) {
# If input genes are ENSEMBL IDs, match directly
matched_genes <- genes[genes$gene %in% gene_list, ]
} else {
# If input genes are symbols, match against cleaned gene symbols
matched_genes <- genes[genes$geneID %in% gene_list | genes$gene %in% gene_list, ]
}
if (nrow(matched_genes) == 0) {
stop("No matching genes found in the Seurat object. Check gene names.")
}
# Create expression matrix averaged by identity
logNormExpres <- as.data.frame(t(as.matrix(
seuratDat[matched_genes$gene, ]
)))
logNormExpres <- logNormExpres %>%
mutate(cell = rownames(.)) %>%
left_join(clusterAssigned, by = "cell") %>%
dplyr::select(-cell) %>%
group_by(ident) %>%
summarise_all(mean, .groups = 'drop')
# Convert to matrix format for heatmap
logNormExpresMa <- logNormExpres %>%
dplyr::select(-ident) %>%
as.matrix()
rownames(logNormExpresMa) <- logNormExpres$ident
logNormExpresMa <- t(logNormExpresMa)
# Clean up gene names (remove ENSEMBL prefix if present)
rownames(logNormExpresMa) <- gsub("^.*?\\.", "", rownames(logNormExpresMa))
# Remove genes with zero variance across all groups
zero_var_genes <- apply(logNormExpresMa, 1, sd) == 0
if (any(zero_var_genes)) {
logNormExpresMa <- logNormExpresMa[!zero_var_genes, , drop = FALSE]
warning(paste("Removed", sum(zero_var_genes), "genes with zero variance across groups"))
}
# Order genes to create "staircase" pattern - genes ordered by which cluster has highest expression
if (!cluster_rows) {
# Find which cluster has max expression for each gene
max_clusters <- apply(logNormExpresMa, 1, function(x) colnames(logNormExpresMa)[which.max(x)])
# Order genes by their max-expressing cluster, then by max expression level within cluster
gene_order <- names(sort(factor(max_clusters, levels = colnames(logNormExpresMa))))
# Within each cluster group, order genes by decreasing max expression
ordered_genes <- c()
for (cluster in colnames(logNormExpresMa)) {
cluster_genes <- names(max_clusters[max_clusters == cluster])
if (length(cluster_genes) > 0) {
# Order by decreasing expression in that cluster
cluster_gene_order <- cluster_genes[order(logNormExpresMa[cluster_genes, cluster], decreasing = TRUE)]
ordered_genes <- c(ordered_genes, cluster_gene_order)
}
}
# Reorder the matrix
logNormExpresMa <- logNormExpresMa[ordered_genes, , drop = FALSE]
}
# Set default color palette for heatmap
if (is.null(color_palette)) {
color_palette <- colorRampPalette(c("#2166AC", "#F7F7F7", "#B2182B"))(50)
}
# Create annotation for columns (cell types/groups)
annotation_col <- data.frame(
Group = colnames(logNormExpresMa)
)
rownames(annotation_col) <- colnames(logNormExpresMa)
# Get the actual groups present in the data (after averaging)
groups_present <- unique(annotation_col$Group)
n_groups <- length(groups_present)
# Set default annotation colors if not provided
if (is.null(annotation_colors)) {
# Define nice color palettes
disease_colors <- c("#dfc27d", "#BE3144", "#202547", "#355C7D", "#779d8d")
fibroblast_colors <- c("#D53E4F", "#f4a582", "#ff7b7b", "#8e0b00", "#FEE08B",
"#42090D", "#FF7B00", "#FFF4DF")
nice_colors <- c("#67001f", "#D53E4F", "#f4a582", "#FEE08B", "#003c30", "#01665e",
"#66C2A5", "#3288BD", "#BEAED4", "#c7eae5", "#355C7D", "#202547",
"#B45B5C", "#8c510a")
extended_colors <- c("#fde0dd", "#fa9fb5", "#d95f0e", "#dd1c77", "#D53E4F",
"#f4a582", "#FEE08B", "#f03b20", "#ffffcc", "#43a2ca",
"#1c9099", "#355C7D", "#3288BD", "#BEAED4", "#756bb1",
"#c7eae5")
large_palette <- c(
"#fde0dd", "#fa9fb5", "#f768a1", "#dd1c77", "#980043",  # pink–magenta
"#f4a582", "#fdae61", "#f46d43", "#d73027", "#a50026",  # orange–red
"#fee08b", "#ffffbf", "#e6f598", "#99d594", "#66c2a5",  # warm–green
"#43a2ca", "#1c9099", "#016c59", "#3288bd", "#5e4fa2",  # teal–blue–purple
"#beaed4", "#9e9ac8", "#756bb1", "#542788", "#3f007d",  # purple tones
"#c7eae5", "#a6bddb", "#74a9cf", "#3690c0", "#045a8d"   # cool blue range
)
# Choose color palette based on group names and count
if (n_groups <= 5 && any(grepl("healthy|explant|visit", groups_present, ignore.case = TRUE))) {
# Disease condition colors
group_colors <- disease_colors[1:n_groups]
} else if (n_groups <= 8 && any(grepl("Fb|Periv|VSMC", groups_present, ignore.case = TRUE))) {
# Fibroblast colors
group_colors <- fibroblast_colors[1:n_groups]
} else if (n_groups <= 14) {
# General nice colors for clusters
group_colors <- nice_colors[1:n_groups]
} else if (n_groups <= 16) {
# Extended colors for 15-16 groups
group_colors <- extended_colors[1:n_groups]
} else if (n_groups <= 30) {
# Large palette for 17-30 groups
group_colors <- large_palette[1:n_groups]
} else {
# For very many groups (>30), use large palette + rainbow
group_colors <- c(large_palette, rainbow(n_groups - length(large_palette)))
}
names(group_colors) <- groups_present
annotation_colors <- list(Group = group_colors)
} else {
# User provided annotation_colors - need to process it
# If user provided a vector, wrap it in a list
if (is.vector(annotation_colors) && !is.list(annotation_colors)) {
# Check if the vector has names
if (!is.null(names(annotation_colors))) {
# Named vector - filter to only groups present in data
group_colors <- annotation_colors[names(annotation_colors) %in% groups_present]
# Check if we have colors for all groups
if (length(group_colors) < n_groups) {
missing_groups <- setdiff(groups_present, names(group_colors))
warning("Some groups are missing from annotation_colors. ",
"Missing: ", paste(missing_groups, collapse = ", "))
# Add default colors for missing groups
default_colors <- rainbow(length(missing_groups))
names(default_colors) <- missing_groups
group_colors <- c(group_colors, default_colors)
}
} else {
# Unnamed vector - assign to groups in order
if (length(annotation_colors) < n_groups) {
warning("annotation_colors has ", length(annotation_colors),
" colors but there are ", n_groups, " groups. ",
"Adding default colors for remaining groups.")
# Extend with default colors
extra_colors <- rainbow(n_groups - length(annotation_colors))
annotation_colors <- c(annotation_colors, extra_colors)
} else if (length(annotation_colors) > n_groups) {
message("annotation_colors has more colors than groups. Using first ", n_groups, " colors.")
annotation_colors <- annotation_colors[1:n_groups]
}
# Assign names based on groups present
group_colors <- annotation_colors[1:n_groups]
names(group_colors) <- groups_present
}
annotation_colors <- list(Group = group_colors)
} else if (is.list(annotation_colors)) {
# User provided a list
# Try to find the right element
if ("Group" %in% names(annotation_colors)) {
group_colors <- annotation_colors$Group
} else if (length(annotation_colors) > 0) {
# Use first element
group_colors <- annotation_colors[[1]]
message("Using first element of annotation_colors list for Group colors")
} else {
stop("annotation_colors list is empty")
}
# Filter to groups present
if (!is.null(names(group_colors))) {
group_colors <- group_colors[names(group_colors) %in% groups_present]
# Check if we need to add colors for missing groups
if (length(group_colors) < n_groups) {
missing_groups <- setdiff(groups_present, names(group_colors))
default_colors <- rainbow(length(missing_groups))
names(default_colors) <- missing_groups
group_colors <- c(group_colors, default_colors)
}
} else {
# Unnamed - assign to groups
if (length(group_colors) < n_groups) {
extra_colors <- rainbow(n_groups - length(group_colors))
group_colors <- c(group_colors, extra_colors)
}
names(group_colors) <- groups_present[1:length(group_colors)]
}
annotation_colors <- list(Group = group_colors)
}
}
# Generate and return heatmap
p <- pheatmap(logNormExpresMa,
scale = scale_method,
cluster_rows = cluster_rows,
cluster_cols = cluster_cols,
color = color_palette,
annotation_col = annotation_col,
annotation_colors = annotation_colors,
cellwidth = cellwidth,
cellheight = cellheight,
show_rownames = show_rownames,
show_colnames = show_colnames,
gaps_row = gaps_row,
gaps_col = gaps_col,
...)
return(p)
}
?fit_mmlt_flexible
plot_correlation_matrix <- function(data = NULL,
cor_matrix = NULL,
p_matrix = NULL,
correlation_type = "pearson",
method = "ellipse",
sig.level = 0.05,
order = "original",
number_size = 0.9,
number.font = 2,
insig = "blank",
label.col = "black",
impute = F,
verbose = T,
clean_names = F,
legend_text_margin = 0.15,
legend_width = 0.15,
legend_height= 0.6,
legend_x_start=1,
legend_y_start=0.9,
legend_title_offset = 0.3) {
if (!requireNamespace("Hmisc", quietly = TRUE) ||
!requireNamespace("corrplot", quietly = TRUE) ||
!requireNamespace("viridis", quietly = TRUE)) {
stop("Please install 'Hmisc', 'corrplot' and 'viridis'.")
}
# if (!requireNamespace("biostatUZH", quietly = TRUE)) {
#   stop(
#     "Package 'biostatUZH' is required for p-value formatting.\n",
#     "Install it with one of the following:\n",
#     "  remotes::install_github(\"EBPI-Biostatistics/biostatUZH\")\n",
#     "  install.packages(\"biostatUZH\", repos = \"http://R-Forge.R-project.org\")"
#   )
# }
# Helper function to clean variable names
clean_variable_names <- function(names) {
names <- gsub("_", " ", names)
split_words <- strsplit(names, " ")
cleaned <- lapply(split_words, function(words) {
sapply(words, function(w) {
if (nchar(w) <= 3) {
toupper(w)               # Make short words ALL CAPS
} else {
tools::toTitleCase(w)    # Title case for longer words
}
})
})
cleaned <- sapply(cleaned, paste, collapse = " ")
return(cleaned)
}
if (!is.null(data)) {
# Remove columns that are entirely NA
all_na_cols <- names(data)[colSums(is.na(data)) == nrow(data)]
if (length(all_na_cols) > 0) {
cat("Removing columns with only NA values:", paste(all_na_cols, collapse = ", "), "\n")
}
data <- data[, colSums(is.na(data)) < nrow(data), drop = FALSE]
cat("After removing all-NA columns:", dim(data), "\n")
# Remove rows that are entirely NA
all_na_rows <- which(rowSums(is.na(data)) == ncol(data))
if (length(all_na_rows) > 0) {
cat("Removing rows with only NA values:", paste(all_na_rows, collapse = ", "), "\n")
}
data <- data[rowSums(is.na(data)) < ncol(data), , drop = FALSE]
cat("After removing all-NA rows:", dim(data), "\n")
if(impute){
if (!requireNamespace("mice", quietly = TRUE) ) {
stop("Please install 'mice' for the imputation.")
}
if (verbose) cat("Performing MICE imputation...\n")
library(mice)
imp.data <- mice(data = data, m = 50, maxit = 10, seed = 12345, printFlag = F)
data <- complete(imp.data)
if (verbose) cat("Imputation completed\n")
}
# Warn if there are non-numeric columns (categorical data)
non_numeric_cols <- names(data)[!sapply(data, is.numeric)]
if (length(non_numeric_cols) > 0) {
warning(
paste0(
"The following columns are non-numeric and will be excluded from the correlation plot: ",
paste(non_numeric_cols, collapse = ", "),
"\nPlease check your data or convert these columns if correlations are desired."
),
call. = FALSE
)
data <- data[, sapply(data, is.numeric), drop = FALSE]
}
cor_results <- Hmisc::rcorr(as.matrix(data), type=correlation_type)
cor_matrix <- cor_results$r
p_matrix <- cor_results$P
# Clean names if requested
if (clean_names) {
cleaned_names <- clean_variable_names(rownames(cor_matrix))
rownames(cor_matrix) <- cleaned_names
colnames(cor_matrix) <- cleaned_names
rownames(p_matrix) <- cleaned_names
colnames(p_matrix) <- cleaned_names
}
} else if (is.null(cor_matrix) || is.null(p_matrix)) {
stop("If 'data' is not provided, both 'cor_matrix' and 'p_matrix' must be supplied.")
} else {
# Clean names for provided matrices if requested
if (clean_names) {
cleaned_names <- clean_variable_names(rownames(cor_matrix))
rownames(cor_matrix) <- cleaned_names
colnames(cor_matrix) <- cleaned_names
rownames(p_matrix) <- cleaned_names
colnames(p_matrix) <- cleaned_names
}
}
cp <- corrplot::corrplot(cor_matrix,
p.mat = p_matrix,
method = method,
type = "full",
order = order,
insig = "blank",
diag = FALSE,
tl.col = label.col,
number.cex = number_size,
number.font = number.font,
cl.pos = "n",
sig.level = sig.level,
col= colorRampPalette(c("blue", "white", "red"))(100))
cp$corrPos -> p1
# text(p1$x, p1$y, round(p1$corr, 2), cex = number_size)
text_colors <- ifelse(!is.na(p1$corr) & p1$corr < -0.5 & p1$p.value < sig.level, "white", "black")
# Add correlations on bottom
text(p1$x, p1$y,
labels =  round(p1$corr, 2),
cex = number_size,
col = text_colors,
font = 1)
# Extract coordinates and add p-values
pos <- cp$corrPos
row_names <- rownames(cor_matrix)
col_names <- colnames(cor_matrix)
get_p <- function(xname, yname) {
i <- match(yname, row_names)
j <- match(xname, col_names)
return(p_matrix[i, j])
}
pos$pval <- mapply(get_p, pos$xName, pos$yName)
pos
# Filter for upper triangle only (where x > y)
upper_triangle <- pos[pos$x + pos$y -1 > length(unique(pos$y)), ]
upper_triangle
upper_triangle$pval_text <- sapply(upper_triangle$pval, formatPval)
# Filter for significant p-values (< 0.05) for colored circles
significant <- upper_triangle[!is.na(upper_triangle$pval) & upper_triangle$pval < sig.level, ]
# Create viridis color mapping for significant p-values
library(viridis)
if (nrow(significant) > 0) {
# Map p-values from 0 to 0.05 to viridis colors
# Lower p-values get more intense colors
p_range <- c(min(upper_triangle$pval), 0.05)
# Normalize p-values to 0-1 scale, then invert so lower p-values = higher color intensity
color_scale <- 1 - (significant$pval - p_range[1]) / (p_range[2] - p_range[1])
# color_scale <- color_scale**2 # extra color boost possible
circle_colors <- viridis(100)[pmax(1, pmin(100, round(color_scale * 100)))]
}
# Clear the upper triangle by drawing white rectangles
margin <- 0.49
for (i in 1:length(unique(pos$y)) ) {
for (j in 1:length(unique(pos$y)) ) {
if(i+j-1 > length(unique(pos$y))) {
# cat(i, j, "\n")
rect(i - margin, j - margin,
i + margin, j + margin,
col = "white", border = NA)
}
}
}
# Add colored circles for significant p-values
if (nrow(significant) > 0) {
circle_radius <- 0.35  # Adjust size as needed
for (i in 1:nrow(significant)) {
# Draw filled circle
theta <- seq(0, 2*pi, length.out = 100)
x_circle <- significant$x[i] + circle_radius * cos(theta)
y_circle <- significant$y[i] + circle_radius * sin(theta)
polygon(x_circle, y_circle, col = circle_colors[i], border = NA)
}
}
# Add p-value text on top with adaptive color
# Use white text for p-values < 0.03 (dark viridis background), black for others
text_colors <- ifelse(!is.na(upper_triangle$pval) & upper_triangle$pval > 0.03 & upper_triangle$pval < sig.level, "white", "black")
# Add p-value text on top
text(upper_triangle$x, upper_triangle$y,
labels = upper_triangle$pval_text,
cex = number_size,
col = text_colors,
font = 1)
# Get plot dimensions for legend positioning
plot_dims <- par("usr")
n_vars <- ncol(cor_matrix)
# Add custom correlation legend (Red-White-Blue)
legend_height <- n_vars * legend_height
legend_x_start <- n_vars + legend_x_start
legend_y_start <- n_vars * legend_y_start
# Create correlation color gradient
cor_colors <- c(
colorRampPalette(c("red", "white"))(50),
colorRampPalette(c("white", "blue"))(50)
)
# Draw correlation legend rectangles
legend_step <- legend_height / 100
for (i in 1:100) {
y_pos <- legend_y_start - (i-1) * legend_step
rect(legend_x_start, y_pos - legend_step,
legend_x_start + legend_width, y_pos,
col = cor_colors[i], border = NA)
}
require(stringr)
# Add correlation legend labels and title
text(legend_x_start + legend_width/2, legend_y_start + legend_title_offset,
paste(stringr::str_to_title(correlation_type),"\nCorrelation"), cex = number_size, font = 2, xpd = TRUE)
text(legend_x_start + legend_width + legend_text_margin, legend_y_start, "1", cex = number_size, xpd = TRUE)
text(legend_x_start + legend_width + legend_text_margin, legend_y_start - legend_height/2, "0", cex = number_size, xpd = TRUE)
text(legend_x_start + legend_width + legend_text_margin, legend_y_start - legend_height, "-1", cex = number_size, xpd = TRUE)
# Add custom p-value legend (Viridis) if there are significant values
if (nrow(significant) > 0) {
pval_legend_x_start <- legend_x_start + legend_width + 0.8
# Create viridis color gradient
viridis_colors <- rev(viridis(100))
# Draw p-value legend rectangles
for (i in 1:100) {
y_pos <- legend_y_start - (i-1) * legend_step
rect(pval_legend_x_start, y_pos - legend_step,
pval_legend_x_start + legend_width, y_pos,
col = viridis_colors[i], border = NA)
}
# Add p-value legend labels and title
text(pval_legend_x_start + legend_width/2, legend_y_start + legend_title_offset,
"P-value", cex = number_size, font = 2, xpd = TRUE)
text(pval_legend_x_start + legend_width + legend_text_margin, legend_y_start, "0.0", cex = number_size, xpd = TRUE)
text(pval_legend_x_start + legend_width + legend_text_margin, legend_y_start - legend_height/2, paste(sig.level/2), cex = number_size, xpd = TRUE)
text(pval_legend_x_start + legend_width + legend_text_margin, legend_y_start - legend_height, paste(sig.level), cex = number_size, xpd = TRUE)
}
}
plot_correlation_matrix(iris)
devtools::check()
devtools::check()
usethis::use_r("mmlt_gof.R")
devtools::check()
devtools::check()
plot_correlation_matrix(mtcars, pval_color_low = "white", pval_color_high = "purple")
devtools::check()
